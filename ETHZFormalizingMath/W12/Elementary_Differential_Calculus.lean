import Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv
import Mathlib.Analysis.Calculus.Deriv.Pow
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.Normed.Operator.BanachSteinhaus
import Mathlib.Analysis.Normed.Module.FiniteDimension
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv
import Mathlib.Analysis.Calculus.ContDiff.RCLike
import Mathlib.Analysis.Calculus.FDeriv.Prod


open Set Filter
open Topology Filter Real

noncomputable section

open Real

/-- The sin function has derivative 1 at 0. -/
example : HasDerivAt sin 1 0 := by simpa using hasDerivAt_sin 0

example (x : â„) : DifferentiableAt â„ sin x :=
  (hasDerivAt_sin x).differentiableAt

example {f : â„ â†’ â„} {x a : â„} (h : HasDerivAt f a x) : deriv f x = a :=
  h.deriv

example {f : â„ â†’ â„} {x : â„} (h : Â¬DifferentiableAt â„ f x) : deriv f x = 0 :=
  deriv_zero_of_not_differentiableAt h

example {f g : â„ â†’ â„} {x : â„} (hf : DifferentiableAt â„ f x) (hg : DifferentiableAt â„ g x) :
    deriv (f + g) x = deriv f x + deriv g x :=
  deriv_add hf hg

example {f : â„ â†’ â„} {a : â„} (h : IsLocalMin f a) : deriv f a = 0 :=
  h.deriv_eq_zero

open Set

example {f : â„ â†’ â„} {a b : â„} (hab : a < b) (hfc : ContinuousOn f (Icc a b)) (hfI : f a = f b) :
    âˆƒ c âˆˆ Ioo a b, deriv f c = 0 :=
  exists_deriv_eq_zero hab hfc hfI

example (f : â„ â†’ â„) {a b : â„} (hab : a < b) (hf : ContinuousOn f (Icc a b))
    (hf' : DifferentiableOn â„ f (Ioo a b)) : âˆƒ c âˆˆ Ioo a b, deriv f c = (f b - f a) / (b - a) :=
  exists_deriv_eq_slope f hab hf hf'

example : deriv (fun x : â„ â†¦ x ^ 5) 6 = 5 * 6 ^ 4 := by simp

example : deriv sin Ï€ = -1 := by simp



open Asymptotics

section

variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ] {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ğ•œ E] {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]


example {Î± : Type*} {E : Type*} [NormedGroup E] {F : Type*} [NormedGroup F] (c : â„)
    (l : Filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) : IsBigOWith c l f g â†” âˆ€á¶  x in l, â€–f xâ€– â‰¤ c * â€–g xâ€– :=
  isBigOWith_iff

example {Î± : Type*} {E : Type*} [NormedGroup E] {F : Type*} [NormedGroup F]
    (l : Filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) : f =O[l] g â†” âˆƒ C, IsBigOWith C l f g :=
  isBigO_iff_isBigOWith

example {Î± : Type*} {E : Type*} [NormedGroup E] {F : Type*} [NormedGroup F]
    (l : Filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) : f =o[l] g â†” âˆ€ C > 0, IsBigOWith C l f g :=
  isLittleO_iff_forall_isBigOWith

example {Î± : Type*} {E : Type*} [NormedAddCommGroup E] (l : Filter Î±) (f g : Î± â†’ E) :
    f ~[l] g â†” (f - g) =o[l] g :=
  Iff.rfl

section

open Topology

variable {ğ•œ : Type*} [NontriviallyNormedField ğ•œ] {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ğ•œ E] {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]

example (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (xâ‚€ : E) :
    HasFDerivAt f f' xâ‚€ â†” (fun x â†¦ f x - f xâ‚€ - f' (x - xâ‚€)) =o[ğ“ xâ‚€] fun x â†¦ x - xâ‚€ :=
  hasFDerivAtFilter_iff_isLittleO ..

example (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (xâ‚€ : E) (hff' : HasFDerivAt f f' xâ‚€) : fderiv ğ•œ f xâ‚€ = f' :=
  hff'.fderiv

example (n : â„•) (f : E â†’ F) : E â†’ E[Ã—n]â†’L[ğ•œ] F :=
  iteratedFDeriv ğ•œ n f

example (n : â„•âˆ) {f : E â†’ F} :
    ContDiff ğ•œ n f â†”
      (âˆ€ m : â„•, (m : WithTop â„•) â‰¤ n â†’ Continuous fun x â†¦ iteratedFDeriv ğ•œ m f x) âˆ§
        âˆ€ m : â„•, (m : WithTop â„•) < n â†’ Differentiable ğ•œ fun x â†¦ iteratedFDeriv ğ•œ m f x :=
  contDiff_iff_continuous_differentiable

example {ğ•‚ : Type*} [RCLike ğ•‚] {E : Type*} [NormedAddCommGroup E] [NormedSpace ğ•‚ E] {F : Type*}
    [NormedAddCommGroup F] [NormedSpace ğ•‚ F] {f : E â†’ F} {x : E} {n : WithTop â„•âˆ}
    (hf : ContDiffAt ğ•‚ n f x) (hn : 1 â‰¤ n) : HasStrictFDerivAt f (fderiv ğ•‚ f x) x :=
  hf.hasStrictFDerivAt hn

section LocalInverse
variable [CompleteSpace E] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E}

example (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) : F â†’ E :=
  HasStrictFDerivAt.localInverse f f' a hf

example (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :
    âˆ€á¶  x in ğ“ a, hf.localInverse f f' a (f x) = x :=
  hf.eventually_left_inverse

example (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :
    âˆ€á¶  x in ğ“ (f a), f (hf.localInverse f f' a x) = x :=
  hf.eventually_right_inverse

example {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E}
  (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :
    HasStrictFDerivAt (HasStrictFDerivAt.localInverse f f' a hf) (f'.symm : F â†’L[ğ•œ] E) (f a) :=
  HasStrictFDerivAt.to_localInverse hf

end LocalInverse

#check HasFDerivWithinAt

#check HasFDerivAtFilter

end
end
